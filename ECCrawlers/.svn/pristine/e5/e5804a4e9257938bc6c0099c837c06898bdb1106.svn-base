package com.isentia.util;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.net.URL;
import java.nio.charset.Charset;
import java.text.SimpleDateFormat;
import java.util.Calendar;

import net.sf.json.JSONException;
import net.sf.json.JSONObject;

import org.apache.lucene.document.Document;
import org.apache.lucene.document.Field;
import org.apache.lucene.index.IndexWriter;
import org.apache.lucene.index.IndexWriter.MaxFieldLength;
import org.apache.lucene.queryParser.ParseException;
import org.apache.lucene.queryParser.QueryParser;
import org.apache.lucene.search.BooleanQuery;
import org.apache.lucene.search.Hits;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.Query;
import org.apache.lucene.store.Directory;
import org.apache.lucene.store.RAMDirectory;

import com.brandtology.analyzer.StandardAnalyzer;

public class ECUtil {

	public static boolean checkIsValidProduct(String keyword, String content) throws IOException,ParseException{
		String query = getQueryString(keyword);
		Directory index = new RAMDirectory();
		IndexWriter writer = new IndexWriter(index, new StandardAnalyzer(new String[0]), true, new MaxFieldLength(1000000));
		Document doc = new Document();
		doc.add(new Field("post_content", content, Field.Store.YES,
				Field.Index.ANALYZED));
		try {
			writer.addDocument(doc);
		} catch (IOException e) {
			System.out.println("IOException adding Lucene Document: "
					+ e.getMessage());
		}
		try {
			writer.optimize();
			writer.close();
		} catch (IOException e) {
			System.out.println("IOException closing Lucene IndexWriter: "
					+ e.getMessage());
		}

		String TIME_FORMAT = "yyyy-MM-dd";
		SimpleDateFormat sdf = new SimpleDateFormat(TIME_FORMAT);

		Calendar calTo = Calendar.getInstance();
		calTo.add(Calendar.DATE, -3);

		IndexSearcher indexSearcher = new IndexSearcher(index);

		String queryString = query;

		String[] fields = { "post_title", "post_content" };
		BooleanQuery.setMaxClauseCount(1000000);
		QueryParser qp = new QueryParser(fields[1], new StandardAnalyzer(
				new String[0]));
		Query q = qp.parse(queryString);
		q = q.rewrite(indexSearcher.getIndexReader());
		Hits hits = indexSearcher.search(q);
		int hitCount = hits.length();
		if(hitCount >= 1){
			return true;
		}else{
			return false;
		}
		
	}
	
	
	private static String getQueryString (String keyword){
		if (keyword.equals("パンパース")){
			return "パンパース  NOT ムーニー NOT メリーズ NOT おむつケーキ NOT 出産祝 NOT おしりふき NOT お尻ふき NOT ローション NOT 母乳 NOT ティッシュ NOT クリーム NOT オムツケーキふ NOT ォッシュ NOT クリーム NOT マミーポコ NOT ハギーズ NOT グーン NOT ネピア NOT Genki";
		}else if (keyword.equals("ムーニー")){
			return "ムーニー NOT パンパース NOT メリーズ NOT おむつケーキ NOT 出産祝 NOT おしりふき NOT お尻ふき NOT ローション NOT 母乳 NOT ティッシュ NOT クリーム NOT オムツケーキふ NOT ォッシュ NOT クリーム NOT マミーポコ NOT ハギーズ NOT グーン NOT ネピア NOT Genki";
		}else if (keyword.equals("メリーズ")){
			return "メリーズ NOT パンパース NOT ムーニー NOT おむつケーキ NOT 出産祝 NOT おしりふき NOT お尻ふき NOT ローション NOT 母乳 NOT ティッシュ NOT クリーム NOT オムツケーキふ NOT ォッシュ NOT クリーム NOT マミーポコ NOT ハギーズ NOT グーン NOT ネピア NOT Genki";
		}else if  (keyword.equals("팸퍼스")){
//			return "(Pampers OR Pampas) NOT Huggies NOT \"Super Daddy\" NOT Merries NOT Moony NOT \"Mamy Poko\" NOT Bosomi NOT \"Goo.N\" NOT nabizam NOT \"Swan Diaper\" NOT Magickan NOT kindoh NOT Depend NOT toddien NOT Penelope NOT \"Paul Mom\" NOT Cottony NOT bebelux NOT Dasomi NOT Oboso NOT Cutie NOT Beffys NOT Loviia NOT \"Nature love Mere\" NOT Soom NOT \"True Love\" NOT kibie NOT Gumbi NOT SUBES NOT \"Natural Blossom\" NOT Genki NOT \"I Do\" NOT agabang NOT \"Daddy Baby\" NOT \"Zoe & Loy\" NOT wipes NOT wipe NOT tissue NOT tissues NOT cake NOT cakes NOT Lotion NOT cream NOT milk NOT Formula NOT \"Body Wash\" NOT bath NOT Shampoo NOT Bag NOT pouch";
//			return "팸퍼스 NOT 하기스 NOT 슈퍼대디 NOT 메리즈 NOT 무니 NOT 마미포코 NOT 보소미 NOT 군 NOT 나비잠 NOT 백조기저귀 NOT 매직캔 NOT 킨도 NOT 디펜드 NOT 토디앙 NOT 페넬로페 NOT 폴맘 NOT 코트니 NOT 베베룩스 NOT 다소미 NOT 오보소 NOT 큐티 NOT 베피스 NOT 러비아 NOT 네이쳐 NOT 숨앤숨 NOT 참사랑 NOT 키비 NOT 금비 NOT 슈베스 NOT 네추럴 NOT 겐키 NOT 아이두 NOT 아가방 NOT 대디베이비 NOT 조이로이 NOT 티슈 NOT 화장지 NOT \"기저귀 케이크\" NOT 다이퍼케익 NOT 기저귀케익 NOT 로션 NOT 크림 NOT 우유 NOT 분유 NOT 바디워시 NOT 비누 NOT 샴푸  NOT 안심팬티 NOT 러브스";
			return "팸퍼스 NOT 티슈 NOT 화장지 NOT 로션 NOT 크림 NOT 우유 NOT 분유 NOT 바디워시 NOT 비누 NOT 샴푸 NOT 파우더 NOT 안심팬티 NOT 러브스";
		
		}else if  (keyword.equals("하기스")){
//			return "(Huggies OR Huggis OR Haggies) NOT Pampers NOT \"Super Daddy\" NOT Merries NOT Moony NOT \"Mamy Poko\" NOT Bosomi NOT \"Goo.N\" NOT nabizam NOT \"Swan Diaper\" NOT Magickan NOT kindoh NOT Depend NOT toddien NOT Penelope NOT \"Paul Mom\" NOT Cottony NOT bebelux NOT Dasomi NOT Oboso NOT Cutie NOT Beffys NOT Loviia NOT \"Nature love Mere\" NOT Soom NOT \"True Love\" NOT kibie NOT Gumbi NOT SUBES NOT \"Natural Blossom\" NOT Genki NOT \"I Do\" NOT agabang NOT \"Daddy Baby\" NOT \"Zoe & Loy\" NOT wipes NOT wipe NOT tissue NOT tissues NOT cake NOT cakes NOT Lotion NOT cream NOT milk NOT Formula NOT \"Body Wash\" NOT bath NOT Shampoo NOT Bag NOT pouch NOT powder";
//			return "하기스 NOT 팸퍼스 NOT 슈퍼대디 NOT 메리즈 NOT 무니 NOT 마미포코 NOT 보소미 NOT 군 NOT 나비잠 NOT 백조기저귀 NOT 매직캔 NOT 킨도 NOT 디펜드 NOT 토디앙 NOT 페넬로페 NOT 폴맘 NOT 코트니 NOT 베베룩스 NOT 다소미 NOT 오보소 NOT 큐티 NOT 베피스 NOT 러비아 NOT 네이쳐 NOT 숨앤숨 NOT 참사랑 NOT 키비 NOT 금비 NOT 슈베스 NOT 네추럴 NOT 겐키 NOT 아이두 NOT 아가방 NOT 대디베이비 NOT 조이로이 NOT 티슈 NOT 화장지 NOT \"기저귀 케이크\" NOT 다이퍼케익 NOT 기저귀케익 NOT 로션 NOT 크림 NOT 우유 NOT 분유 NOT 바디워시 NOT 비누 NOT 샴푸 NOT 파우더  NOT 안심팬티";
			return "하기스 NOT 티슈 NOT 화장지 NOT 로션 NOT 크림 NOT 우유 NOT 분유 NOT 바디워시 NOT 비누 NOT 샴푸 NOT 파우더 NOT 안심팬티";
		}else{
			return "";
		}
	}
	
	public static String convertUnicode(String keyword){
		if(keyword.equals("ムーニー")){
			return "%83%80%81%5B%83j%81%5B";
		}
		if(keyword.equals("パンパース")){
			return "%83p%83%93%83p%81%5B%83X";
		}
		if(keyword.equals("メリーズ")){
			return "%83%81%83%8A%81%5B%83Y";
		}
		return "";
	}
	
	private static String readAll(Reader rd) throws IOException {
		StringBuilder sb = new StringBuilder();
		int cp;
		while ((cp = rd.read()) != -1) {
			sb.append((char) cp);
		}
		return sb.toString();
	}

	public static JSONObject readJsonFromUrl(String url,String charset) throws IOException,
			JSONException {
		InputStream is = new URL(url).openStream();
		try {
			BufferedReader rd = new BufferedReader(new InputStreamReader(is,
					Charset.forName(charset)));
			String jsonText = readAll(rd);
			JSONObject json = JSONObject.fromObject(jsonText);
			return json;
		} finally {
			is.close();
		}
	}
}
